// required FFI and resources
require javascript
require stdout

// imports
import javascript:stdlib.js
import javascript:stdlib.support.regexUtils
import wyvernLexer
import wyvernParser
import bytecode
import raw
import binding
import bound
import toBytecode
import wyvern.collections.llist

// instantiate imports and create aliases
type List = llist.LinkedList
val wyvernLexer = wyvernLexer(js, regexUtils)
val toBytecode = toBytecode(javascript, js)
val b = bytecode(javascript, js)

val lexer = wyvernLexer.makeLexer()

val parser = wyvernParser.makeParser(lexer)

// TODO: right now there's an internal error in nearly if there's a parse error.  Need to fix this; somehow we are using nearly wrong.
// simple test case
parser.feed("def f(x) = x\nval y = ( x => x)\n( x => x) (x => x)")

//parser.feed("(x => x)")
/* debugging code, currently commented out
    js.log("Raw Results:\n")
    js.log(parser.results)
    js.log("Results:\n")
    stdout.print(raw.expToString(parser.results.get(0)))
*/

stdout.print("Binding...\n")
val boundExp = binding.bind(parser.results.get(0))
        
stdout.print("Lowering...\n")
val ooExp = bound.lower(boundExp)

stdout.print("Writing to sample.wyb...\n")
toBytecode.writeExpToFile(ooExp, "sample.wyb")
