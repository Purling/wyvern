// required FFI and resources
require javascript
require stdout

// imports
import javascript:stdlib.js
import javascript:stdlib.support.regexUtils
import wyvernLexer
import wyvernParser
import bytecode
import raw
import binding
import bound
import toBytecode
import wyvern.collections.llist
import types
import typecheck

// instantiate imports and create aliases
type List = llist.LinkedList
val wyvernLexer = wyvernLexer(js, regexUtils)
val toBytecode = toBytecode(javascript, js)
val b = bytecode(javascript, js)

val lexer = wyvernLexer.makeLexer()

val parser = wyvernParser.makeParser(lexer)

// TODO: right now there's an internal error in nearly if there's a parse error.  Need to fix this; somehow we are using nearly wrong.
// simple test case
//parser.feed("def f(x) = x\nval y = ( x => x)\n( x => x) (x => x)\n(x => x) (003+3202 * (65537 % 2) / -2 + -(2 - 3))\ntype foo:\n    val x:Int\n    val y:Int\n5\n")
//parser.feed("type Int:\n    def +(i:Int):Int\n    def -(i:Int):Int\nval x = 5\nval y = x\nval z = y\nz+0-x+3+5")
parser.feed("type Int:\n    def +(i:Int):Int\n    def -(i:Int):Int\n    val a:Int\nval x = 5\n-x.a.a+3-x")
/* debugging code, currently commented out
*/
js.log("Raw Results:\n")
js.log(parser.results)
js.log("Results:\n")

stdout.print(raw.expToString(parser.results.get(0)))
stdout.println()

def parse(s:String):raw.Exp
    val lex = wyvernLexer.makeLexer()
    val pars = wyvernParser.makeParser(lex)
    pars.feed(s)
    pars.results.get(0)

stdout.print("Binding...\n")
val boundExp = binding.bind(parser.results.get(0), s => parse(s))

val tc = typecheck.typecheck(boundExp)
stdout.print("type: " + types.typeToString(tc))
stdout.println()

stdout.print("Lowering...\n")
val ooExp = bound.lower(boundExp)

stdout.print("Writing to sample.wyb...\n")
toBytecode.writeExpToFile(ooExp, "sample.wyb")
/*testing parsing
*/
