module types

import wyvern.option
import wyvern.collections.llist
import error
type Option = option.Option
type List = llist.LinkedList

resource type Counter
    var value:Int
def Counter():Counter = new
    var value:Int = 0

type Binding
    val name:String
    val id:Int
def Binding(name:String, c:Counter):Binding
    val count = c.value
    c.value = c.value + 1
    new
        val name = name
        val id = count

def findInDeclList[T](gamma:List[DeclType], pred:DeclType->Option[T]):T
    def f(gamma:List[DeclType], pred:DeclType->Option[T]):Option[T]
        match gamma:
            c:llist.Cons => 
                match (pred(c.value)):
                    s:option.Some => s
                    default => f(c.next, pred)
            n:llist.Nil => option.None[T]()
    match f(gamma, pred):
        s:option.Some => s.get()
        default => error.report("search in decllist failed",error.unknownLocation)

def unfoldType(x:Type, gamma:List[DeclType]):UnfoldedType
    match x:
        u:UnitType => UnfoldedType(llist.Nil[DeclType]())
        x:NominalType => 
            val pred = ((b:DeclType) =>
                val z = match b:
                    t:TypeType => if (equalBinding(x.L, t.name)) { option.Some[TypeType](t) } else { option.None[TypeType]() }
                    default => option.None[TypeType]()
                z
            )
            unfoldType(findInDeclList[TypeType](gamma, pred).typ, gamma)
        u:UnfoldedType => u

def equalBinding(b1:Binding, b2:Binding):Boolean
    b1.name == b2.name && b1.id == b2.id

//nominal types that point to other nominal types form a tree,
//so we find the "root" nominal type to compare if two aliases are equal
def getNominalRoot(n:NominalType, gamma:List[DeclType]):NominalType
    val pred = ((b:DeclType) =>
        val z = match b:
            t:TypeType => if (equalBinding(t.name, n.L)) { option.Some[TypeType](t) } else { option.None[TypeType]() }
            default => option.None[TypeType]()
        z
    )
    val par = findInDeclList[TypeType](gamma, pred)
    match par.typ:
        nn:NominalType => getNominalRoot(nn,gamma)
        default => n

def checkArgList(xs:List[Type],ys:List[Type],pred:Type->Type->Boolean):Boolean
    if (xs.size() != ys.size())
        false
      else
        def f(xs:List[Type],ys:List[Type]):Boolean = match xs:
            a:llist.Cons => match ys:
                b:llist.Cons =>   
                    (pred(a.value)(b.value)) && f(a.next,b.next)
            default => true
        f(xs,ys)

def equalDeclType(a:DeclType, b:DeclType, gamma:List[DeclType]):Boolean
    match a:
        v:ValType => match b:
            u:ValType => v.name.name == u.name.name && equalType(v.typ,u.typ,gamma)
            default => false
        t:TypeType => match b:
            u:TypeType => t.name.name == u.name.name && equalType(t.typ,u.typ,gamma)
            default => false
        d:DefType => match b:
            u:DefType => 
                val pred = x:Type => y:Type => equalType(x,y,gamma)
                d.name.name == u.name.name && checkArgList(d.args,u.args,pred) && equalType(d.retTyp,u.retTyp,gamma)
            default => false

def equalType(t1:Type, t2:Type, gamma:List[DeclType]):Boolean
    match t1:
        u:UnitType => match t2:
            v:UnitType => true
            default => equalType(unfoldType(t1,gamma),t2,gamma)
        n:NominalType => match t2:
            v:NominalType => 
                val r1 = getNominalRoot(n,gamma)
                val r2 = getNominalRoot(v,gamma)
                equalBinding(r1.L, r2.L)
            default => equalType(unfoldType(t1,gamma),t2,gamma)
        u:UnfoldedType => match t2:
            v:UnfoldedType =>
                def isValidDecl(d:DeclType):Boolean
                    val search = llist.find[DeclType](u.decls, (e:DeclType) => equalDeclType(e,d,gamma))
                    match search:
                        s:option.Some => true
                        default => false
                v.decls.foldRight[Boolean]((x:DeclType,y:Boolean) => isValidDecl(x) && y, true)
            default => equalType(t1,unfoldType(t2,gamma),gamma)

type SubtypePair
    val S:Type
    val T:Type

def SubtypePair(S:Type, T:Type):SubtypePair = new
    val S = S
    val T = T

def isSubtypeDecl(a:DeclType, b:DeclType, gamma:List[DeclType], stack:List[SubtypePair]):Boolean = match a:
    v:ValType => match b:    
        u:ValType => v.name.name == u.name.name && isSubtypeHelper(v.typ,u.typ,gamma,stack)
        default => false
    t:TypeType => match b:
        u:TypeType => t.name.name == u.name.name && equalType(t.typ,u.typ,gamma)
        default => false
    d:DefType => match b:
        u:DefType => 
            val pred = x:Type => y:Type => isSubtypeHelper(x,y,gamma,stack)
            d.name.name == u.name.name && checkArgList(d.args,u.args,pred) && isSubtypeHelper(d.retTyp,u.retTyp,gamma,stack)
        default => false

def isSubtype(t1:Type, t2:Type, gamma:List[DeclType]):Boolean
    isSubtypeHelper(t1,t2,gamma,llist.Nil[SubtypePair]())

def isSubtypeHelper(t1:Type, t2:Type, gamma:List[DeclType], stack:List[SubtypePair]):Boolean
    //if t1 <: t2 appears within its own judgement, return true
    val findPrev = llist.find[SubtypePair](stack, (j:SubtypePair) => equalType(j.S,t1,gamma) && equalType(j.T,t2,gamma))
    match findPrev:
        s:option.Some => true    
        default => 
            if (equalType(t1,t2,gamma))
                true
              else
                val newstack = llist.Cons[SubtypePair](SubtypePair(t1,t2), stack)
                val u = unfoldType(t1,gamma)
                val v = unfoldType(t2,gamma)
                def isValidDecl(d:DeclType):Boolean
                    val search = llist.find[DeclType](u.decls, (e:DeclType) => isSubtypeDecl(e,d,gamma,newstack))
                    match search:
                        s:option.Some => true
                        default => false
                v.decls.foldRight[Boolean]((x:DeclType,y:Boolean) => isValidDecl(x) && y, true)

datatype Type
    UnitType()
    NominalType(L:Binding)
    UnfoldedType(decls:List[DeclType])

datatype DeclType
    ValType(name:Binding, typ:Type)
    TypeType(name:Binding, typ:Type)
    DefType(name:Binding, args:List[Type], retTyp:Type)

def declTypeToString(d:DeclType):String = match d:
    v:ValType => "val " + v.name.name + ":" + typeToString(v.typ)
    t:TypeType => "type " + t.name.name + ":" + typeToString(t.typ)
    d:DefType => "def " + d.name.name + "(args):" + typeToString(d.retTyp)

def typeToString(t:Type):String = match t:
    u:UnitType => "Unit"
    n:NominalType => n.L.name
    u:UnfoldedType => 
        val s = u.decls.map[String](e => declTypeToString(e))
        s.foldLeft[String]((x:String,y:String) => x + ", " + y, "UNFLD: { ") + " }"
