module types

import wyvern.option
import wyvern.collections.llist
import error
type Option = option.Option
type List = llist.LinkedList

resource type Counter
    var value:Int
def Counter():Counter = new
    var value:Int = 0

type Binding
    val name:String
    val id:Int
def Binding(name:String, c:Counter):Binding
    val count = c.value
    c.value = c.value + 1
    new
        val name = name
        val id = count

def equalBinding(b1:Binding, b2:Binding):Boolean
    b1.name == b2.name && b1.id == b2.id
//////////////////////////////
datatype BaseType
    UnitType()
    NominalType(L:Binding)

type Type
    val base:BaseType
    val refines:List[DeclType]
def Type(b:BaseType, r:List[DeclType]):Type = new
    val base = b
    val refines = r
def makeNominalType(L:Binding):Type = new
    val base = NominalType(L)
    val refines = llist.Nil[DeclType]()
def makeRefines(ls:List[DeclType]):Type = new
    val base = UnitType()
    val refines = ls

datatype DeclType
    ValType(name:Binding, typ:Type)
    TypeType(name:Binding, unfld:Type)
    DefType(name:Binding, args:List[Type], retTyp:Type)

val theUnit = Type(UnitType(),llist.Nil[DeclType]())
//////////////////////////////
def findInDeclList[T](gamma:List[DeclType], pred:DeclType->Option[T]):T
    def f(gamma:List[DeclType], pred:DeclType->Option[T]):Option[T]
        match gamma:
            c:llist.Cons => 
                match (pred(c.value)):
                    s:option.Some => s
                    default => f(c.next, pred)
            n:llist.Nil => option.None[T]()
    match f(gamma, pred):
        s:option.Some => s.get()
        default => error.report("search in decllist failed",error.unknownLocation)

def unfoldType(x:Type, gamma:List[DeclType]):List[DeclType]
    val decls = match x.base:
        u:UnitType => llist.Nil[DeclType]()
        x:NominalType => 
            val pred = ((b:DeclType) =>
                val z = match b:
                    t:TypeType => if (equalBinding(x.L, t.name)) { option.Some[TypeType](t) } else { option.None[TypeType]() }
                    default => option.None[TypeType]()
                z
            )
            unfoldType(findInDeclList[TypeType](gamma, pred).unfld,gamma)
    x.refines.append(decls)

//Check if two lists of arguments line up in the right way
def checkArgList(xs:List[Type],ys:List[Type],pred:Type->Type->Boolean):Boolean
    if (xs.size() == ys.size())
        def f(xs:List[Type],ys:List[Type]):Boolean = match xs:
            a:llist.Cons => match ys:
                b:llist.Cons =>   
                    (pred(a.value)(b.value)) && f(a.next,b.next)
            default => true
        f(xs,ys)
      else
        false

//Check if for each y in ys there is an x in xs s.t. (pred x y) is true
def checkDeclList(xs:List[DeclType],ys:List[DeclType],pred:DeclType->DeclType->Boolean):Boolean
    def isValid(d:DeclType):Boolean
        val search = llist.find[DeclType](xs, (e:DeclType) => pred(e)(d))
        match search:
            s:option.Some => true
            default => false
    ys.foldRight[Boolean]((x:DeclType,y:Boolean) => isValid(x) && y, true)

def equalDeclType(a:DeclType, b:DeclType, gamma:List[DeclType]):Boolean
    match a:
        v:ValType => match b:
            u:ValType => v.name.name == u.name.name && equalType(v.typ,u.typ,gamma)
            default => false
        t:TypeType => match b:
            u:TypeType => 
                val tt = unfoldType(makeNominalType(t.name),gamma)
                val uu = unfoldType(makeNominalType(u.name),gamma)
                t.name.name == u.name.name && checkDeclList(tt,uu,x=>y=>equalDeclType(x,y,gamma))
            default => false
        d:DefType => match b:
            u:DefType => 
                val pred = x:Type => y:Type => equalType(x,y,gamma)
                d.name.name == u.name.name && checkArgList(d.args,u.args,pred) && equalType(d.retTyp,u.retTyp,gamma)
            default => false

def equalBaseType(a:BaseType, b:BaseType):Boolean = match a:
    u:UnitType => match b:
        v:UnitType => true
        default => false
    n:NominalType => match b:
        v:NominalType => equalBinding(n.L,v.L)
        default => false

def equalType(t1:Type, t2:Type, gamma:List[DeclType]):Boolean
    val pred = x:DeclType => y:DeclType => equalDeclType(x,y,gamma)
    equalBaseType(t1.base,t2.base) && checkDeclList(t1.refines,t2.refines,pred)

type SubtypePair
    val S:Type
    val T:Type
def SubtypePair(S:Type, T:Type):SubtypePair = new
    val S = S
    val T = T

def isSubtypeDecl(a:DeclType, b:DeclType, gamma:List[DeclType]):Boolean = match a:
    v:ValType => match b:    
        u:ValType => v.name.name == u.name.name && isSubtype(v.typ,u.typ,gamma)
        default => false
    t:TypeType => match b:
        u:TypeType => equalDeclType(a,b,gamma)
        default => false
    d:DefType => match b:
        u:DefType => 
            val pred = x:Type => y:Type => isSubtype(x,y,gamma)
            d.name.name == u.name.name && checkArgList(u.args,d.args,pred) && isSubtype(d.retTyp,u.retTyp,gamma)
        default => false

def isSubtype(t1:Type, t2:Type, gamma:List[DeclType]):Boolean
    if (equalType(t2,theUnit,gamma))
        true
      else
        isSubtypeBase(t1,t2.base,gamma) && checkDeclList(t1.refines,t2.refines,x=>y=>isSubtypeDecl(x,y,gamma))

def isSubtypeBase(t1:Type, t2:BaseType, gamma:List[DeclType]):Boolean
    true

def combineStringList(ls:List[String]):String = match ls:
    c:llist.Cons => match c.next:
        n:llist.Nil => c.value
        cc:llist.Cons => c.value + ", " + combineStringList(c.next)
    default => ""

def declTypeToString(d:DeclType):String = match d:
    v:ValType => "val " + v.name.name + ":" + typeToString(v.typ)
    t:TypeType => "type " + t.name.name + ":" + typeToString(t.unfld)
    d:DefType => 
        val arglist = d.args.map[String](t => typeToString(t))
        "def " + d.name.name + "(" + combineStringList(arglist) + "):" + typeToString(d.retTyp)

def typeToString(t:Type):String
    val baseString = match t.base:
        u:UnitType => "Unit"
        n:NominalType => n.L.name
    val s = t.refines.map[String](e => declTypeToString(e))
    val refinesString = combineStringList(s)
    baseString + " {" + refinesString + "}"
