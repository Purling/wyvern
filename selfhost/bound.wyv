module bound

import raw

import wyvern.collections.llist
type List = llist.LinkedList

resource type Counter
    var value:Int
def Counter():Counter = new
    var value:Int = 0

resource type Context
    val bindings:List[Binding]
    val counter:Counter
    val parse:String -> raw.Exp
    def extend(b:Binding):Context

def Context(bs:List[Binding], c:Counter, p:String -> raw.Exp) : Context = new
    val bindings = bs
    val counter = c
    val parse = p
    def extend(b:Binding):Context
        Context(llist.Cons[Binding](b, bs), c, p)
    
def emptyContext(p:String -> raw.Exp):Context = Context(llist.Nil[Binding](), Counter(), p)


type Binding
    val name:String
    val id:Int
def Binding(name:String, c:Counter):Binding
    val count = c.value
    c.value = c.value + 1
    new
        val name = name
        val id = count

type Method
    val name:String
    val binding:Binding
    val body:Exp

def Method(name:String, binding:Binding, body:Exp):Method = new
    val name = name
    val binding = binding
    val body = body

datatype DeclType
    ValType(name:Binding, typ:String)  // eventually the type will be a Type not a String
    
datatype Exp
    Var(binding:Binding)
    App(func:Exp, arg:Exp)
    Lambda(binding:Binding, body:Exp)
    Obj(meths:List[Method])
    Call(receiver:Exp, name:String, arg:Exp)
    Val(binding:Binding, exp:Exp)
    TypeDecl(name:Binding, members:List[DeclType])
    Seq(exps:List[Exp])
    Integer(str:String)
    UnitVal()

def lower(e:Exp):Exp = match e:
    v:Var     => v
    a:App     => Call(lower(a.func), "apply", lower(a.arg))
    l:Lambda  => Obj(llist.Singleton[Method](Method("apply", l.binding, lower(l.body))))
    c:Call    => Call(lower(c.receiver),c.name,lower(c.arg))
    v:Val     => Val(v.binding, lower(v.exp))
    s:Seq     => Seq(s.exps.map[Exp](e => lower(e)))
    i:Integer    => i
    t:TypeDecl => UnitVal()
