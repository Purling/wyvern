module typecheck

import types
import bound
import error
import wyvern.collections.llist
type List = llist.LinkedList
type DeclType = types.DeclType

/*
def searchGamma[T](gamma:List[DeclType], pred:DeclType->Boolean):T
    val opt = llist.find[DeclType](gamma, pred)
    match opt:
        s:option.Some => 
            val ret:DeclType = opt.get()
            match ret:
                t:T => t
                default => error.report("search in gamma failed",error.unknownLocation)
        n:option.None => error.report("search in gamma failed",error.unknownLocation)
*/

def unfoldType(x:types.Type, gamma:List[DeclType]):types.UnfoldedType
    match x:
        u:types.UnitType => types.UnfoldedType(llist.Nil[DeclType]())
        x:types.NominalType => 
            val pred = ((b:DeclType) =>
                val z = match b:
                    t:types.TypeType => types.equalBinding(x.L, t.name)
                    default => false
                z
            )
            val ret = llist.find[DeclType](gamma, pred).get()
            match ret:
                t:types.TypeType => t.typ
                default => error.report("unfolding error",error.unknownLocation)
        u:types.UnfoldedType => u


def typecheck(e:bound.Exp):types.Type
    getType(e,llist.Nil[DeclType]())

def getType(e:bound.Exp, gamma:List[DeclType]):types.Type = match e:
    v:bound.Var =>
        val pred = ((b:DeclType) => 
            val z = match b:
                va:types.ValType => types.equalBinding(v.binding,va.name)
                default => false
            z
        )
        val value = llist.find[DeclType](gamma, pred).get()
        match value:
            va:types.ValType => va.typ
            default => error.report("var not bound",error.unknownLocation)

    c:bound.Call => //T-Invk
        val recType = getType(c.receiver, gamma)
        val unfold:types.UnfoldedType = unfoldType(recType, gamma)
        val pred = ((b:DeclType) =>
            val z = match b:
                da:types.DefType => c.name == da.name.name && types.equalType(getType(c.arg,gamma), da.argTyp)
                default => false
            z
        )
        val meth = llist.find[DeclType](unfold.decls, pred).get()
        match meth:
            da:types.DefType => da.retTyp
            default => error.report("method not found",error.unknownLocation)

    s:bound.Seq => typeSeq(s.exps,gamma)

    i:bound.Integer => 
        val pred = ((b:DeclType) =>
            val z = match b:
                tt:types.TypeType => tt.name.name == "Int"
                default => false
            z
        )
        val t = llist.find[DeclType](gamma, pred).get()  
        match t:
            tt:types.TypeType => types.NominalType(tt.name)
            default => error.report("aaa",error.unknownLocation)

    default => error.report("type error: not implemented yet",error.unknownLocation)

def typeSeq(es:List[bound.Exp], gamma:List[DeclType]):types.Type = match es:
    c:llist.Cons =>
        match c.next:
            n:llist.Nil => getType(c.value, gamma) //last expression
            cc:llist.Cons => 
                match c.value:
                    v:bound.Val => 
                        val typ = getType(v.exp, gamma)
                        val vt = types.ValType(v.binding, typ)
                        val gammaPrime = llist.Cons[DeclType](vt, gamma)
                        typeSeq(c.next, gammaPrime)
                    t:bound.TypeDecl =>
                        val tt = types.TypeType(t.name, types.UnfoldedType(t.members))
                        val gammaPrime = llist.Cons[DeclType](tt, gamma)
                        typeSeq(c.next, gammaPrime)
                    default =>
                        val typ = getType(c.value, gamma)
                        typeSeq(c.next, gamma)
    n:llist.Nil => error.report("program doesn't end in an expression", error.unknownLocation)
