module typecheck

import types
import typesUtil
import error
import wyvern.option
import wyvern.collections.llist
import wyvern.pair

type Option = option.Option
type List = llist.LinkedList
type Binding = types.Binding
type Type = types.Type
type BaseType = types.BaseType
type DeclType = types.DeclType
type ValType = types.ValType
type TypeType = types.TypeType
type DefType = types.DefType
type SubtypeType = types.SubtypeType
type MemberType = types.MemberType
type UnitType = types.UnitType
type NominalType = types.NominalType
type PathType = types.PathType
type Pair = pair.Pair

def typecheck(e:types.Statement):Type
    typecheckStmt(e,llist.Nil[DeclType]())

def typecheckStmt(e:types.Statement, gamma:List[DeclType]):Type = match e:
    d:types.DeclStatement => 
        val dc:DeclType = typecheckDecl(d.decl, gamma)
        val gammaPrime:List[DeclType] = llist.Cons[DeclType](dc, gamma)
        typecheckStmt(d.stmt, gammaPrime)
    e:types.ExprStatement => 
        typecheckExpr(e.exp, gamma)

def typecheckDecl(e:types.Decl, gamma:List[DeclType]):DeclType = match e:
    v:types.Val => 
        val typ = typecheckExpr(v.exp, gamma)
        types.ValType(v.binding, typ)
    t:types.TypeDecl =>
        types.TypeType(t.name, t.z, t.typ)
    d:types.Def =>
        val argdecls:List[DeclType] = d.args.map[ValType]((a:types.Arg) => types.ValType(a.arg,a.argTyp))
        val testType = typecheckStmt(d.body, argdecls.append(gamma))
        if (true /*TODO: subtyping.isSubtype(testType, d.retTyp, gamma)*/)
            types.DefType(d.binding, d.args, d.retTyp)
          else
            error.report("def decl is not well-formed",error.unknownLocation)
    s:types.SubtypeDecl =>
        if (true /*TODO: subtyping.checkSubtypeWF(s.subtype, s.supertype, gamma)*/)
            types.SubtypeType(s.subtype, s.supertype)
          else
            error.report("subtype decl is not well-formed",error.unknownLocation)
    t:types.TypeEq =>
        types.MemberType(t.name, types.EQ(),t.typ)

def typecheckExpr(e:types.Exp, gamma:List[DeclType]):Type = match e:
    v:types.Var =>
        val pred = ((b:DeclType) => 
            val z = match b:
                va:ValType => 
                    if (types.equalBinding(v.binding,va.name)) { option.Some[ValType](va) } else { option.None[ValType]() }
                default => option.None[ValType]()
            z
        )
        typesUtil.findInDeclList[ValType](gamma, pred).typ

    c:types.Call => //T-Invk
        val recType = typecheckExpr(c.receiver, gamma)
        val unfold = unfoldType(recType, gamma)
        val argtypes:List[Type] = c.args.map[Type](e => typecheckExpr(e,gamma))

        //val subcheck = x:Type => y:Type => subtyping.isSubtype(x,y,gamma)
        val pred = ((b:DeclType) =>
            val z = match b:
                da:DefType => 
                    if (c.name == da.name.name && true /*TODO: subtyping.checkArgList(argtypes,da.args,subcheck)*/) { option.Some[DefType](da) } else { option.None[DefType]() }
                default => option.None[DefType]()
            z
        )
        val func = typesUtil.findInDeclList[DefType](unfold.decls, pred)
        //Do substitutions to get the correct return type
        val retTyp = types.substituteType(func.retTyp, c.receiver, unfold.z)
        val argBindings = func.args.map[Binding](a => a.arg)
        val zipargs = typesUtil.zip[types.Exp,Binding](c.args,argBindings)
        zipargs.foldRight[Type]((x:Pair[types.Exp,Binding],t:Type)=>types.substituteType(t,x.first,option.Some[Binding](x.second)),retTyp)

    f:types.Field => //T-Field
        val recType = typecheckExpr(f.receiver, gamma)
        val unfold = unfoldType(recType, gamma)
        val pred = ((b:DeclType) =>
            val z = match b:
                va:ValType => 
                    if (f.field == va.name.name) { option.Some[ValType](va) } else { option.None[ValType]() }
                default => option.None[ValType]()
            z
        )
        val tauV = typesUtil.findInDeclList[ValType](unfold.decls, pred).typ
        types.substituteType(tauV, f.receiver, unfold.z)

    n:types.New => //T-New
        val unfold = unfoldType(n.typ, gamma)
        def typeNewDecls(d:types.Decl):DeclType
            val thisType = types.ValType(n.binding, n.typ)
            val ngamma = llist.Cons[DeclType](thisType, gamma)
            match d:
                v:types.Val         => typecheckDecl(d, gamma)
                d:types.Def         => typecheckDecl(d, ngamma)
                t:types.TypeDecl    => typecheckDecl(d, ngamma)
                s:types.SubtypeDecl => typecheckDecl(d, ngamma)
                t:types.TypeEq      => typecheckDecl(d, ngamma)
        val decls = n.body.map[DeclType](x => typeNewDecls(x))
        n.typ
    //TODO:do proper check with unfold   /*subtyping.checkDeclList(decls, unfold, x=>y=>subtyping.isSubtypeDecl(x,y,gamma))*/
    //    if (true) {n.typ} else {error.report("invalid new expression",error.unknownLocation)}

    i:types.Integer => 
        val pred = ((b:DeclType) =>
            val z = match b:
                tt:TypeType => 
                    if (tt.name.name == "Int") { option.Some[TypeType](tt) } else { option.None[TypeType]() }
                default => option.None[TypeType]()
            z
        ) 
        val L = typesUtil.findInDeclList[TypeType](gamma, pred).name
        types.makeNominalType(L)

    u:types.UnitVal => types.theUnit

    default => error.report("type error: unrecognized expression",error.unknownLocation)
/////////////////////////////////
//UNFOLD
type Unfold
    val z:Option[Binding]
    val decls:List[DeclType]
def Unfold(z:Option[Binding], decls:List[DeclType]):Unfold = new
    val z = z
    val decls = decls

def findTypePredicate(bind:Binding):DeclType->Option[TypeType]
    val pred = ((b:DeclType) =>
        val z = match b:
            t:TypeType => if (types.equalBinding(bind, t.name)) { option.Some[TypeType](t) } else { option.None[TypeType]() }
            default => option.None[TypeType]()
        z
    )
    pred

def fetchDeclFromList(path:PathType, ls:List[DeclType]):DeclType
    val pred = ((d:DeclType) => 
        val z = match d:
            t:TypeType   => path.t.name == t.name.name 
            m:MemberType => path.t.name == m.name.name //compare just names instead of bindings? I think its ok since just searching in an unfld list like for field names
            default => false
        z
    )
    val search = llist.find[DeclType](ls,pred)
    match search:
        s:option.Some => s.get()
        default => error.report("fetch: type member not found",error.unknownLocation)

def unfoldType(x:Type, gamma:List[DeclType]):Unfold
    val b = match x.base:
        u:UnitType => Unfold(option.None[Binding](),llist.Nil[DeclType]())
        x:NominalType => 
            val pred = findTypePredicate(x.L)
            val tt = typesUtil.findInDeclList[TypeType](gamma, pred)
            Unfold(option.Some[Binding](tt.z),tt.unfld)
        path:PathType =>
                val tau = typecheckExpr(path.p,gamma)
                val pUnfold = unfoldType(tau,gamma)
                val d = fetchDeclFromList(path,pUnfold.decls)
                match d:
                    t:TypeType => 
                        val subUnfold = t.unfld.map[DeclType](e => types.substituteDeclType(e,path.p,pUnfold.z))
                        Unfold(option.Some[Binding](t.z),subUnfold)
                    m:MemberType => match m.bound:
                        g:types.GEQ => Unfold(option.None[Binding](),llist.Nil[DeclType]())
                        default => unfoldType(types.substituteType(m.typ,path.p,pUnfold.z),gamma)
                    default => error.report("should never happend",error.unknownLocation)
    Unfold(b.z,x.refines.append(b.decls))
/////////////////////////////////
//SUBTYPING

//Check if two lists of arguments line up in the right way
def checkArgList(xs:List[Type],ys:List[Type],pred:Type->Type->Boolean):Boolean
    if (xs.size() == ys.size())
        def f(xs:List[Type],ys:List[Type]):Boolean = match xs:
            a:llist.Cons => match ys:
                b:llist.Cons =>   
                    (pred(a.value)(b.value)) && f(a.next,b.next)
            default => true
        f(xs,ys)
      else
        false

//Check if for each y in ys there is an x in xs s.t. (pred x y) is true
def checkDeclList(xs:List[DeclType],ys:List[DeclType],pred:DeclType->DeclType->Boolean):Boolean
    def isValid(d:DeclType):Boolean
        val search = llist.find[DeclType](xs, (e:DeclType) => pred(e)(d))
        match search:
            s:option.Some => true
            default => false
    ys.foldRight[Boolean]((x:DeclType,y:Boolean) => isValid(x) && y, true)

def equalDeclType(a:DeclType, b:DeclType, gamma:List[DeclType]):Boolean = match a:
    v:ValType => match b:
        u:ValType => v.name.name == u.name.name && equalType(v.typ,u.typ,gamma)
        default => false
    t:TypeType => match b:
        u:TypeType => 
            t.name.name == u.name.name && checkDeclList(t.unfld,u.unfld,x=>y=>equalDeclType(x,y,gamma))
        default => false
    d:DefType => match b:
        u:DefType => 
            val pred = x:Type => y:Type => equalType(x,y,gamma)
            val dargs = d.args.map[Type](e => e.argTyp)
            val uargs = u.args.map[Type](e => e.argTyp)
            d.name.name == u.name.name && checkArgList(dargs,uargs,pred) && equalType(d.retTyp,u.retTyp,gamma)
        default => false
    s:SubtypeType => match b:
        u:SubtypeType =>
            equalType(s.subtype,u.subtype,gamma) && equalType(s.supertype,u.supertype,gamma)            
        default => false
    m:MemberType => match b:
        u:MemberType =>
            m.name.name == u.name.name && typesUtil.equalBound(m.bound,u.bound) && equalType(m.typ,u.typ,gamma)
        default => false

def equalBaseType(a:BaseType, b:BaseType, gamma:List[DeclType]):Boolean = match a:
    u:UnitType => match b:
        v:UnitType => true
        default => false
    n:NominalType => match b:
        v:NominalType => types.equalBinding(n.L,v.L)
        default => false
    path:PathType => match b:
        v:PathType => 
            val tauA = typecheckExpr(path.p,gamma)
            val tauB = typecheckExpr(v.p,gamma)
            equalType(tauA,tauB,gamma) && path.t.name == v.t.name
        default => false

def equalType(t1:Type, t2:Type, gamma:List[DeclType]):Boolean
    val pred = x:DeclType => y:DeclType => equalDeclType(x,y,gamma)
    equalBaseType(t1.base,t2.base,gamma) && checkDeclList(t1.refines,t2.refines,pred) && checkDeclList(t2.refines,t1.refines,pred)

def isSubtypeDeclList(xs:List[DeclType], ys:List[DeclType], gamma:List[DeclType]):Boolean
    checkDeclList(xs,ys,x=>y=>isSubtypeDecl(x,y,gamma))

def isSubtypeDecl(a:DeclType, b:DeclType, gamma:List[DeclType]):Boolean = match a:
    v:ValType => match b:    
        u:ValType => v.name.name == u.name.name && isSubtype(v.typ,u.typ,gamma)
        default => false
    t:TypeType => match b:
        u:TypeType => equalDeclType(a,b,gamma)
        default => false
    d:DefType => match b:
        u:DefType => 
            val pred = x:Type => y:Type => isSubtype(x,y,gamma)
            val dargs = d.args.map[Type](e => e.argTyp)
            val uargs = u.args.map[Type](e => e.argTyp)
            d.name.name == u.name.name && checkArgList(uargs,dargs,pred) && isSubtype(d.retTyp,u.retTyp,gamma)
        default => false
    s:SubtypeType => match b:
        u:SubtypeType => equalType(s.subtype,u.subtype,gamma) && equalType(s.supertype,u.supertype,gamma)
        default => false
    m:MemberType => match b:
        //RHS =: LHS =
        //RHS <=: LHS <=, =
        //RHS >=: LHS >=, =
        u:MemberType => 
            if (m.name.name == u.name.name)
                match u.bound:
                    e:types.EQ => match m.bound:
                        ee:types.EQ => equalType(m.typ,u.typ,gamma)   
                        default => false
                    l:types.LEQ => match m.bound:
                        g:types.GEQ => false
                        default => isSubtype(m.typ,u.typ,gamma)
                    g:types.GEQ => match m.bound:
                        l:types.LEQ => false
                        default => isSubtype(u.typ,m.typ,gamma)
              else
                false
        default => false

def isSubtype(t1:Type, t2:Type, gamma:List[DeclType]):Boolean
    val normalAns = (() => 
        if (equalType(t2,types.theUnit,gamma)) { true } else { isSubtypeBase(t1,t2.base,gamma) && isSubtypeDeclList(t1.refines,t2.refines,gamma) }
    )
    true
    //match t1.base:
    //    path:PathType =>
    //        val tau = typecheckExpr(path.p,gamma)
    //        val unfold = unfoldType(tau,gamma)
    //        //TODO            

def isSubtypeBase(t1:Type, t2:BaseType, gamma:List[DeclType]):Boolean
    val b1 = types.Type(t1.base,llist.Nil[DeclType]())
    val b2 = types.Type(t2,llist.Nil[DeclType]())
    if (equalType(b1,b2,gamma))
        true
      else
        val pred = ((b:DeclType) =>
            val z = match b:
                s:types.SubtypeType =>
                    equalBaseType(s.subtype.base,t1.base,gamma) \
                 && isSubtypeDeclList(t1.refines,s.subtype.refines,gamma) \
                 && isSubtypeBase(types.Type(s.supertype.base,t1.refines),t2,gamma)
                default => false
            z
        )
        val listToSearch:List[DeclType] = match t1.base:
            path:PathType => 
                val tau = typecheckExpr(path.p,gamma)
                val unfold = unfoldType(tau,gamma)
                unfold.decls.map[DeclType](d => types.substituteDeclType(d,path.p,unfold.z))
            default => gamma
        val search = llist.find[DeclType](listToSearch,pred)
        match search:
            s:option.Some => true
            default => false

def checkSubtypeWF(t1:Type, t2:Type, gamma:List[DeclType]):Boolean
    true
    //TODO:
    //val ua = types.unfoldType(t1,gamma)
    //val ub = types.unfoldType(t2,gamma)
    //val newgamma = llist.Cons[DeclType](types.SubtypeType(t1,t2),gamma)
    //isSubtypeDeclList(ua,ub,newgamma)
    
