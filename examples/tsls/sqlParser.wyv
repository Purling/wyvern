// module parser

import metadata wyvern.collections.list
import wyvern.util.matching.regex
import tsls.glexer
import wyvern.ast
import wyvern.Int
import wyvern.option
import debug

/* some SQL examples

"CREATE TABLE Students ("
                  + "Name varchar(255),"
                  + "GPA float"
              + ")";
"INSERT INTO Students VALUES ('John',4.0)"
"UPDATE Students SET GPA=3.0 WHERE Name='John'"
"SELECT AVG(GPA) FROM Students"
*/

val tokens = new
	type Kind = Int
    
	val WHITESPACE:this.Kind = 1
	val EOF:this.Kind = 2
	val ERROR:this.Kind = 3
    
	val COMMA:this.Kind = 10
	val LPAREN:this.Kind = 11
	val RPAREN:this.Kind = 12
	val EQUALS:this.Kind = 13
    
	val FLOAT_CONST:this.Kind = 20
	val INT_CONST:this.Kind = 21
	val STRING_CONST:this.Kind = 22
    
	val AVG     :this.Kind = 30
	val CREATE  :this.Kind = 31
	val DROP    :this.Kind = 32
	val FROM    :this.Kind = 33
	val INSERT  :this.Kind = 34
	val INTO    :this.Kind = 35
	val SELECT  :this.Kind = 36
	val SET     :this.Kind = 37
	val TABLE   :this.Kind = 38
	val UPDATE  :this.Kind = 39
	val VALUES  :this.Kind = 40
	val WHERE   :this.Kind = 41
    
	val VARCHAR:this.Kind = 60
	val FLOAT:this.Kind = 61
    
	val IDENTIFIER:this.Kind = 70
	val EMBED_IDENTIFIER:this.Kind = 71

val lexer = glexer(tokens)

// local bindings to make things easier
type AST = ast.AST
type Option = option.Option
type None = option.None

def createScanner(input:String):lexer.Scanner
    // Create a scanner configuration, setting up the whitespace operator
    val config = lexer.makeScannerConfig(regex("[ \n\t]+"))

    // Add regular expressions and corresponding tokens
    config.addTokenKind(regex("\\z")       , tokens.EOF)

    config.addTokenKind(regex(",")       , tokens.COMMA)
    config.addTokenKind(regex("\\(")       , tokens.LPAREN)
    config.addTokenKind(regex("\\)")       , tokens.RPAREN)
    config.addTokenKind(regex("=")       , tokens.EQUALS)

    config.addTokenKind(regex("\\d+\\.\\d+")      , tokens.FLOAT_CONST)
    config.addTokenKind(regex("\\d+")      , tokens.INT_CONST)
    config.addTokenKind(regex("'[^']*'"), tokens.STRING_CONST)

    config.addTokenKind(regex("AVG"), tokens.AVG)
    config.addTokenKind(regex("CREATE"), tokens.CREATE)
    config.addTokenKind(regex("DROP"), tokens.DROP)
    config.addTokenKind(regex("FROM"), tokens.FROM)
    config.addTokenKind(regex("INSERT"), tokens.INSERT)
    config.addTokenKind(regex("INTO"), tokens.INTO)
    config.addTokenKind(regex("SELECT"), tokens.SELECT)
    config.addTokenKind(regex("SET"), tokens.SET)
    config.addTokenKind(regex("TABLE"), tokens.TABLE)
    config.addTokenKind(regex("UPDATE"), tokens.UPDATE)
    config.addTokenKind(regex("VALUES"), tokens.VALUES)
    config.addTokenKind(regex("WHERE"), tokens.WHERE)
    
    config.addTokenKind(regex("VARCHAR"), tokens.VARCHAR)
    config.addTokenKind(regex("FLOAT"), tokens.FLOAT)
    
    config.addTokenKind(regex("\\p{Alpha}\\w*"), tokens.IDENTIFIER)
    config.addTokenKind(regex("\\$\\p{Alpha}\\w*"), tokens.EMBED_IDENTIFIER)
    
    // create a scanner
    lexer.makeScanner(config, input)

////////////////////////////////////////////////////////////////////////////

def debugOut(t:lexer.Token):Unit
    debug.printInt(t.kind())
    debug.print(": ")
    debug.print(t.print())
    debug.println()

def lex(input:String):Unit
    val scanner = createScanner(input)
    
    // print the tokens, one at a time
    val t = scanner.nextToken()
    printTokens(scanner, t)

def printTokens(scanner : lexer.Scanner, token : lexer.Token) : Unit
    debugOut(token)
    val next = scanner.nextToken()
    (next.kind() == tokens.EOF).ifTrue(
       () => unit,
       () => printTokens(scanner, next))

// lex("UPDATE blah")
// lex("UPDATE Students SET GPA=3.0 WHERE Name='John'")
// lex("SELECT AVG(GPA) FROM Students")
// lex("INSERT INTO Students VALUES ('John',4.0)")
// lex("CREATE TABLE Students (Name varchar(255), GPA float)")

////////////////////////////////////////////////////////////////////////////

// A parse function for SQL queries
// SQLStatement ::= SQLInsert | SQLUpdate
def parse(input:String):Option[String]
    val scanner = createScanner(input)

    val token = scanner.nextToken()
    debugOut(token)

    (token.kind() == tokens.INSERT).ifTrue(
        () => parseInsert(scanner),
        () => (token.kind() == tokens.UPDATE).ifTrue(
            () => parseUpdate(scanner),
            () => option.None[String]())) // default is PARSE ERROR

// SQLInsert ::= "INSERT" "IDENTIFIER"
def parseInsert(scanner:lexer.Scanner):Option[String]
    debug.print("Called parseInsert.")
    debug.println()
    
    val token = scanner.nextToken()
    debugOut(token)

    (token.kind() == tokens.EOF).ifTrue(
        () => option.None[String](), // need to have IDENTIFIER
        () => (token.kind() == tokens.IDENTIFIER).ifTrue(
            () => option.Some[String]("Successfully parsed insert and identifier!"),
            () => option.None[String]())) // need to have IDENTIFIER

// SQLUpdate ::= "UPDATE" "IDENTIFIER"
def parseUpdate(scanner:lexer.Scanner):Option[String]
    debug.print("Called parseUpdate.")
    debug.println()
    
    val token = scanner.nextToken()
    debugOut(token)

    (token.kind() == tokens.EOF).ifTrue(
        () => option.None[String](), // need to have IDENTIFIER
        () => (token.kind() == tokens.IDENTIFIER).ifTrue(
            () => option.Some[String]("Successfully parsed update and identifier!"),
            () => option.None[String]())) // need to have IDENTIFIER

////////////////////////////////////////////////////////////////////////////

var testString:String = "UPDATE blah"

debug.print("Trying to parse ")
debug.print(testString)
debug.println()
debug.print(parse(testString).getOrElse(() => "PARSE ERROR"))
debug.println()
