module formatstring

import wyvern.ast
import wyvern.option
import wyvern.util.matching.regex
import metadata wyvern.collections.list

type AST = ast.AST

type ParsedExpr
    def expr():option.Option[AST]
    def rest():String

def makeParsedExpr(e:option.Option[AST],r:String):ParsedExpr = new
    def expr():option.Option[AST] = e
    def rest():String = r

val prefixRegex : regex.Regex = regex("[^%]+")

// recursively determines position of the rbrace ending the expression, -1 if not found
def getExprPos(input : String, lbraceCt : Int, pos : Int) : Int
    (input.length() == pos).ifTrue(
        () => -1,
        () => (input.charAt(pos) == #"}").ifTrue(
            () => (lbraceCt == 0).ifTrue(
                () => pos,
                () => getExprPos(input, lbraceCt - 1, pos+1)
            ),
            () => getExprPos(input, lbraceCt, pos+1)
        )
    )
    
def parseExpr(input : String, ctx: system.Context) : ParsedExpr
    //if %{...}, we want to get the contents of the braces
    val normal : option.Option[String] = regex("%\\{").findPrefixMatchOf(input).map[String]((m:regex.Match) => m.after())
    //val end = getExprPos(normal.get(), 0, 0)
    (normal.isDefined).ifTrue(
        () => (getExprPos(normal.get(), 0, 0) == -1).ifTrue(
            () => makeParsedExpr(option.None[AST](), normal.get()), //error?
            //option.Some[AST](ast.string("parsing error")),//continue parsing or throw error
            () => makeParsedExpr(option.Some[AST](ast.parseExpression(normal.get().substring(0,getExprPos(normal.get(), 0, 0)), ctx)), normal.get().substring(getExprPos(normal.get(), 0, 0)+1, normal.get().length()))
            //option.Some[AST](ast.parseExpression(normal.get().substring(0,getExprPos(normal.get(), 0, 0)), ctx))
            ),
        //if nothing found then default to whole string?
        () => makeParsedExpr(option.None[AST](), input) //WARNING probably loops //option.Some[AST](ast.string("nonstandard formatstring"))
    )
    
    //if %/d./d, ensure formatted float
    
    // %/d
    
    // if none of the above, just append % and continue parsing
    //option.Some[AST](ast.string(input))

type FormatString = String
    metadata new
        def parseTSL(input : String, ctx : system.Context) : option.Option[AST]
            val regxMatch : option.Option[regex.Match] = prefixRegex.findPrefixMatchOf(input)
            val prefixString : option.Option[String] = regxMatch.map[String]((m:regex.Match) => m.matched())
            val rest : option.Option[String] = regxMatch.map[String]((m:regex.Match) => m.after())
            (input == "").ifTrue(
                () => option.Some[AST](ast.string("")),
                () => (prefixString.isDefined).ifTrue(
                    () => option.Some[AST](ast.call(ast.call(ast.string(prefixString.get()), "+", {(parseExpr(rest.getOrElse(() => ""), ctx)).expr().getOrElse(() => ast.string(""))}), "+", {this.parseTSL(parseExpr(rest.getOrElse(() => ""), ctx).rest(), ctx).getOrElse(() => ast.string(""))})),
                    () => option.Some[AST](ast.call(parseExpr(rest.getOrElse(() => input), ctx).expr().getOrElse(() => ast.string("")), "+", {this.parseTSL(parseExpr(rest.getOrElse(() => input), ctx).rest(), ctx).getOrElse(() => ast.string(""))}))
						//g = parseExpr(rest.getOrElse(() => ""), ctx)
                        //option.Some[AST](ast.call(g.expr().getOrElse(() => ast.string("")), "+", {this.parseTSL(g.rest(), ctx).getOrElse(() => ast.string(""))}))
                )
            )
            //option.Some[AST](ast.call(ast.string("hello "), "+", {ast.string("world!")}))
            //option.Some[AST](ast.string(input))










    

    
/** OUTLINE

pull off individual string characters until you reach a % (account for esc later)
then look for either a number, ., or { (regexp matching)
continue parsing and appending strings recursively


*/    
    
/*
def parseString(input:String):option.Option[AST]
    //start by pulling the string before the next % character
    val prefixRegex : regex.Regex = regex("[^%]+")
    val prefixString : option.Option[String] = prefixRegex.findPrefixMatchOf(input).map[String](
                                             (m:regex.Match) => m.after())
    val appendString : String = prefixString.getOrElse(() => input)
    //append appendString to the result of parseExpr()


def parseExpr(input:String):option.Option[AST]
    val exp =
    
    ast.cast(exp, ast.types.string())
*/
    
//%\{.*\}
// shouldn't need to account for {} in primitive Wyvern expressions?? but maybe list methods...
// ^maybe account for this later
// still need to account for escape characters