module formatstring

import wyvern.ast
import wyvern.option
import wyvern.util.matching.regex
import metadata wyvern.collections.list
import wyvern.Int
import wyvern.String

type AST = ast.AST

type ParsedExpr
    def expr():option.Option[AST]
    def rest():String

def makeParsedExpr(e:option.Option[AST],r:String):ParsedExpr = new
    def expr():option.Option[AST] = e
    def rest():String = r

// recursively determines position of the rbrace ending the expression, -1 if not found
// TODO: ignore escape characters (\{, \})
def getExprPos(input : String, lbraceCt : Int, inString : Boolean, pos : Int) : Int
    (input.length() == pos).ifTrue(
        () => -1,
        () => (input.charAt(pos) == #"}").ifTrue(
            () => (lbraceCt == 0 && !inString).ifTrue(
                () => pos,
                () => inString.ifTrue(
					() => getExprPos(input, lbraceCt, inString, pos+1),
					() => getExprPos(input, lbraceCt - 1, inString, pos+1)
				)
            ),
            () => (input.charAt(pos) == #"\"").ifTrue(
				() => getExprPos(input, lbraceCt, !inString, pos+1),
				() => (input.charAt(pos) == #"{" && !inString).ifTrue(
					() => getExprPos(input, lbraceCt+1, inString, pos+1),
					() => getExprPos(input, lbraceCt, inString, pos+1)
				)
			)
        )
    )

// takes in an expression as a string and returns a string wrapped in an AST
def convStringAST(input : String, ctx : system.Context, floatPrecision : Int) : option.Option[AST]
    val exp : AST = ast.parseExpression(input, ctx)
    val ty : ast.Type = ast.getType(exp, ctx)
    //if (ty == ast.types.string())
    option.Some[AST](exp)
    //String.ofInt(x)
    //String.ofFormattedFloat(format: String, f: Float) wait might need to work around this
    //else
    //option.None[AST]()
    

def parseExpr(input : String, ctx : system.Context) : ParsedExpr
    // if %{...}, we want to get the contents of the braces
    val normal : option.Option[String] = regex("%\\{").findPrefixMatchOf(input).map[String]((m:regex.Match) => m.after())
    if (normal.isDefined)
        val eoparse : Int = getExprPos(normal.get(), 0, false, 0)
        (eoparse == -1).ifTrue(
            () => makeParsedExpr(option.None[AST](), normal.get()),
            () => makeParsedExpr(convStringAST(normal.get().substring(0,eoparse), ctx, -1), normal.get().substring(eoparse+1, normal.get().length()))
        )
      else
        val floatspec : option.Option[regex.Match] = regex("%\\.\\d+\\{").findPrefixMatchOf(input)
        val formatspec : option.Option[String] = floatspec.map[String]((m:regex.Match) => m.matched())
        if (floatspec.isDefined)
            val precision : Int = Int.from(formatspec.get().substring(2, formatspec.get().length()-1))
            val floatstring : String = floatspec.get().after()
            val floatstringend : Int = getExprPos(floatstring, 0, false, 0)
            (floatstringend == -1).ifTrue(
                () => makeParsedExpr(option.None[AST](), floatstring),
                () => makeParsedExpr(convStringAST(floatstring.substring(0, floatstringend), ctx, precision),
                                floatstring.substring(floatstringend+1, floatstring.length()))
            )
          else
            // if nothing found then 5 should've been escaped, so throw error
            makeParsedExpr(option.None[AST](), input)
    
    
    //if %/d./d, ensure formatted float
    
    // %/d
    
    // if none of the above, return option.None[AST]

//val prefixRegex : regex.Regex = regex("((\\%)|[^%])+")
//alternative approach: if last char of prefixString is \ and next matches %, replace it with % and append to parseTSL
val prefixRegex : regex.Regex = regex("[^%]+")

//include \% + other characters, except pure %
//TODO: ignore escape character (\%)
type FormatString = String
    metadata new
        def parseTSL(input : String, ctx : system.Context) : option.Option[AST]
            val regxMatch : option.Option[regex.Match] = prefixRegex.findPrefixMatchOf(input)
            val prefixString : option.Option[String] = regxMatch.map[String]((m:regex.Match) => m.matched())
            val rest : option.Option[String] = regxMatch.map[String]((m:regex.Match) => m.after())
            if (input == "")
                option.Some[AST](ast.string(""))
              else
                if (prefixString.isDefined)
                    if (rest.get() == "")
                        option.Some[AST](ast.string(prefixString.get()))
                      else
                        val g : ParsedExpr = parseExpr(rest.getOrElse(() => ""), ctx)
                        if (g.expr().isDefined)
                            val recursiveCall = this.parseTSL(g.rest(), ctx)
                            if (recursiveCall.isDefined)
                                option.Some[AST](ast.call(ast.call(ast.string(prefixString.get()), "+", {g.expr().get()}), "+", {recursiveCall.get()}))
                              else
                                option.None[AST]() //recursive call gives None
                          else
                            option.None[AST]() //cannot parse expression
                  else
                    val g : ParsedExpr = parseExpr(rest.getOrElse(() => input), ctx)
                    if (g.expr().isDefined)
                        val recursiveCall = this.parseTSL(g.rest(), ctx)
                        if (recursiveCall.isDefined)
                            option.Some[AST](ast.call(g.expr().get(), "+", {recursiveCall.get()}))
                          else
                            option.None[AST]() //recursive call gives None
                      else
                        option.None[AST]() //cannot parse expression
                
            










    

    
/** OUTLINE

pull off individual string characters until you reach a % (account for esc later)
then look for either a number, ., or { (regexp matching)
continue parsing and appending strings recursively


*/    
    
/*
def parseString(input:String):option.Option[AST]
    //start by pulling the string before the next % character
    val prefixRegex : regex.Regex = regex("[^%]+")
    val prefixString : option.Option[String] = prefixRegex.findPrefixMatchOf(input).map[String](
                                             (m:regex.Match) => m.after())
    val appendString : String = prefixString.getOrElse(() => input)
    //append appendString to the result of parseExpr()


def parseExpr(input:String):option.Option[AST]
    val exp =
    
    ast.cast(exp, ast.types.string())
*/
    
//%\{.*\}
// shouldn't need to account for {} in primitive Wyvern expressions?? but maybe list methods...
// ^maybe account for this later
// still need to account for escape characters