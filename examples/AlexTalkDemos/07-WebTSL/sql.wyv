module sql

import metadata wyvern.collections.list
import wyvern.util.matching.regex
import tsls.glexer
import wyvern.ast
import wyvern.Int
import wyvern.option
import debug
import metadata wyvern.collections.list

/* some SQL examples

"CREATE TABLE Students ("
                  + "Name varchar(255),"
                  + "GPA float"
              + ")";
"INSERT INTO Students VALUES ('John',4.0)"
"UPDATE Students SET GPA=3.0 WHERE Name='John'"
"SELECT AVG(GPA) FROM Students"
*/

val tokens = new
	type Kind = Int
    
	val WHITESPACE:this.Kind = 1
	val EOF:this.Kind = 2
	val ERROR:this.Kind = 3
    
	val COMMA:this.Kind = 10
	val LPAREN:this.Kind = 11
	val RPAREN:this.Kind = 12
	val EQUALS:this.Kind = 13
    
	val FLOAT_CONST:this.Kind = 20
	val INT_CONST:this.Kind = 21
	val STRING_CONST:this.Kind = 22
    
	val AVG     :this.Kind = 30
	val CREATE  :this.Kind = 31
	val DROP    :this.Kind = 32
	val FROM    :this.Kind = 33
	val INSERT  :this.Kind = 34
	val INTO    :this.Kind = 35
	val SELECT  :this.Kind = 36
	val SET     :this.Kind = 37
	val TABLE   :this.Kind = 38
	val UPDATE  :this.Kind = 39
	val VALUES  :this.Kind = 40
	val WHERE   :this.Kind = 41
    
	val VARCHAR:this.Kind = 60
	val FLOAT:this.Kind = 61
    
	val IDENTIFIER:this.Kind = 70
	val EMBED_IDENTIFIER:this.Kind = 71

val lexer = glexer(tokens)

// local bindings to make things easier
type AST = ast.AST
type Option = option.Option
type None = option.None

def createScanner(input:String):lexer.Scanner
    // Create a scanner configuration, setting up the whitespace operator
    val config = lexer.makeScannerConfig(regex("[ \n\t]+"))

    // Add regular expressions and corresponding tokens
    config.addTokenKind(regex("\\z")       , tokens.EOF)

    config.addTokenKind(regex(",")       , tokens.COMMA)
    config.addTokenKind(regex("\\(")       , tokens.LPAREN)
    config.addTokenKind(regex("\\)")       , tokens.RPAREN)
    config.addTokenKind(regex("=")       , tokens.EQUALS)

    config.addTokenKind(regex("\\d+\\.\\d+")      , tokens.FLOAT_CONST)
    config.addTokenKind(regex("\\d+")      , tokens.INT_CONST)
    config.addTokenKind(regex("'[^']*'"), tokens.STRING_CONST)

    config.addTokenKind(regex("AVG"), tokens.AVG)
    config.addTokenKind(regex("CREATE"), tokens.CREATE)
    config.addTokenKind(regex("DROP"), tokens.DROP)
    config.addTokenKind(regex("FROM"), tokens.FROM)
    config.addTokenKind(regex("INSERT"), tokens.INSERT)
    config.addTokenKind(regex("INTO"), tokens.INTO)
    config.addTokenKind(regex("SELECT"), tokens.SELECT)
    config.addTokenKind(regex("SET"), tokens.SET)
    config.addTokenKind(regex("TABLE"), tokens.TABLE)
    config.addTokenKind(regex("UPDATE"), tokens.UPDATE)
    config.addTokenKind(regex("VALUES"), tokens.VALUES)
    config.addTokenKind(regex("WHERE"), tokens.WHERE)
    
    config.addTokenKind(regex("VARCHAR"), tokens.VARCHAR)
    config.addTokenKind(regex("FLOAT"), tokens.FLOAT)
    
    config.addTokenKind(regex("\\p{Alpha}\\w*"), tokens.IDENTIFIER)
    config.addTokenKind(regex("\\$\\p{Alpha}\\w*"), tokens.EMBED_IDENTIFIER)
    
    // create a scanner
    lexer.makeScanner(config, input)

////////////////////////////////////////////////////////////////////////////

def debugOut(t:lexer.Token):Unit
    debug.printInt(t.kind())
    debug.print(": ")
    debug.print(t.print())
    debug.println()

def lex(input:String):Unit
    val scanner = createScanner(input)
    
    // print the tokens, one at a time
    val t = scanner.nextToken()
    printTokens(scanner, t)

def printTokens(scanner : lexer.Scanner, token : lexer.Token) : Unit
    debugOut(token)
    val next = scanner.nextToken()
    (next.kind() == tokens.EOF).ifTrue(
       () => unit,
       () => printTokens(scanner, next))

// lex("UPDATE blah")
// lex("UPDATE Students SET GPA=3.0 WHERE Name='John'")
// lex("SELECT AVG(GPA) FROM Students")
// lex("INSERT INTO Students VALUES ('John',4.0)")
// lex("CREATE TABLE Students (Name varchar(255), GPA float)")

////////////////////////////////////////////////////////////////////////////

// SQLInsert ::= "INSERT" "IDENTIFIER"
def parseInsert(scanner : lexer.Scanner):Option[AST]
  debug.print("Called parseInsert.")
  debug.println()
  val token = scanner.nextToken()
  // debugOut(token)
  
  if (token.kind() == tokens.EOF)
      option.None[AST]() // need to have IDENTIFIER
    else
      if (token.kind() == tokens.IDENTIFIER)
          val defEval = ast.defDeclaration("eval", list.make[ast.FormalArg](), ast.types.string(),
            ast.string("Successfully parsed insert and identifier (" + token.print() + ")!"))
          val declList : list.List[ast.Decl] = list.make[ast.Decl]()
          declList.append(defEval)
          option.Some(ast.object(declList))
        else
          option.None[AST]() // need to have IDENTIFIER

// SQLInsert ::= "UPDATE" "IDENTIFIER"
def parseUpdate(scanner : lexer.Scanner):Option[AST]
  debug.print("Called parseUpdate.")
  debug.println()
  val token = scanner.nextToken()
  // debugOut(token)
  
  if (token.kind() == tokens.EOF)
      option.None[AST]() // need to have IDENTIFIER
    else
      if (token.kind() == tokens.IDENTIFIER)
          val defEval = ast.defDeclaration("eval", list.make[ast.FormalArg](), ast.types.string(),
            ast.string("Successfully parsed update and identifier (" + token.print() + ")!"))
          val declList : list.List[ast.Decl] = list.make[ast.Decl]()
          declList.append(defEval)
          option.Some(ast.object(declList))
        else
          option.None[AST]() // need to have IDENTIFIER

// Parse until EOF.
def parseAllSQLStatements(scanner : lexer.Scanner) : list.List[AST]
  var list : list.List[AST] = list.make[AST]()
  parseAllSQLStatementsHelper(scanner, list)

def parseAllSQLStatementsHelper(scanner : lexer.Scanner, list : list.List[AST]) : list.List[AST]
  val token = scanner.nextToken()
  // debugOut(token)
  var ast : option.Option[AST] = option.None[AST]()

  if (token.kind() != tokens.EOF)
    if (token.kind() == tokens.INSERT)
        ast = parseInsert(scanner)
      else
        if (token.kind() == tokens.UPDATE)
          ast = parseUpdate(scanner)
    if (ast.isDefined)
      list.append(ast.get())

  list

////////////////////////////////////////////////////////////////////////////

type SQLExpr
  def eval() : String

  metadata new
    // A parse function for SQL queries
    // SQLStatement ::= SQLInsert | SQLUpdate
    def parseTSL(input : String, ctx : system.Context) : option.Option[AST]
      val scanner = createScanner(input)

      val sqlStatements : list.List[AST] = parseAllSQLStatements(scanner)
      debug.print("Found ")
      debug.printInt(sqlStatements.length())
      debug.print(" SQL statements.\n")

      val defEval = ast.defDeclaration("eval", list.make[ast.FormalArg](), ast.types.string(),
        ast.string("Successfully parsed some SQL statements!"))
      val declList : list.List[ast.Decl] = list.make[ast.Decl]()
      declList.append(defEval)
      option.Some(ast.object(declList))
