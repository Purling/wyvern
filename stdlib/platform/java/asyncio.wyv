module def asyncio(java : Java)

import java:wyvern.stdlib.support.NIO.nio

import future
import bytebuffer

val future = future(java)
val bytebuffer = bytebuffer(java)

type ByteBuffer = bytebuffer.ByteBuffer

// TCP
type Socket
    def read(buf : ByteBuffer) : future.Future[Int]
    def write(buf : ByteBuffer) : future.Future[Int]
    def close() : Unit

// TCP
type ServerSocket
    def accept() : future.Future[Socket]

/*
// can configure for async, but just returns null instead of blocking
// UDP
type DatagramChannel
    //def bind(port : Int) : Unit
    //maxSize? timeout?
    def receive(buf : ByteBuffer) : Option[Packet]
    def send(buf : ByteBuffer, hostname : String, port : Int) : Int
    
type DatagramPacket
    val data : ByteBuffer
    val hostaddr : String
    val port : Int

def makeDatagramChannel(port : Int) : DatagramChannel = new
    val chan = nio.makeDatagramChannel(port)
*/


def makeServerSocket(port : Int) : ServerSocket
    val channel = nio.makeServerSocketChannel(port)
    def makeSocketFromChannel(channel:Unit) : Socket = new
        def read(buf:ByteBuffer):future.Future[Int] = future.Future[Int](nio.socketRead(channel,buf.buffer))
        def write(buf:ByteBuffer):future.Future[Int] = future.Future[Int](nio.socketWrite(channel,buf.buffer))
        def close():Unit = nio.socketClose(channel)
    new
        def accept() : future.Future[Socket]
            future.Future[Unit](nio.serverAccept(channel)).andThen[Socket](
                (channel:Unit) => makeSocketFromChannel(channel)
            )
/*
def makeSocket(hostname : String, port : Int) : future.Future[Socket]
    val channel = nio.makeSocketChannel()
    val connected : future.Future[Unit] = future.Future[Unit](nio.socketChannelConnect(channel, hostname, port))
    val socket : Socket = new
        def read(buf : ByteBuffer) : future.Future[Int]
            future.Future[Int](nio.socketRead(channel, buf.buffer))
        def write(buf : ByteBuffer) : future.Future[Int]
            future.Future[Int](nio.socketWrite(channel, buf.buffer))
        def close() : Unit
            nio.socketClose(channel)
    new
        type T = Socket
        def get() : Socket
            val wait = connected.get() //blocks until done
            socket
        def isCancelled() : Boolean = connected.isCancelled()
        def isDone() : Boolean = connected.isDone()
        def cancel() : Boolean = connected.cancel()
        def andThen[U](cb : this.T -> U) : future.Future[U]
            val conv = (() => 
                socket
            )
            val temp : future.Future[this.T] = connected.andThen[this.T](conv)
            temp.andThen[U](cb)
*/
