module def asyncio(java : Java)

import java:wyvern.stdlib.support.NIO.nio

import future

val future = future(java)

type ByteBuffer
    val size : Int
    def get(index : Int) : Int
    def set(index : Int, value : Int) : Unit
    // maybe writing strings? reading UTF? bytebuffer class with methods for creating from string, etc.

// TCP
type Socket
    def read(buf : ByteBuffer) : future.Future[Int]
    def write(buf : ByteBuffer) : future.Future[Int]
    def close() : Unit

// TCP
type ServerSocket
    def accept() : future.Future[Socket]

/*
// can configure for async, but just returns null instead of blocking
// UDP
type DatagramChannel
	//def bind(port : Int) : Unit
	//maxSize? timeout?
	def receive(buf : ByteBuffer) : Option[Packet]
	def send(buf : ByteBuffer, hostname : String, port : Int) : Int
	
type DatagramPacket
	val data : ByteBuffer
	val hostaddr : String
	val port : Int
*/


def makeServerSocket(port : Int) : ServerSocket
    val channel = nio.makeServerSocketChannel(port)
    def makeSocketFromChannel(channel:Unit) : Socket = new
        def read(buf:ByteBuffer):future.Future[Int] = future.Future[Int](nio.socketRead(channel,buf))
        def write(buf:ByteBuffer):future.Future[Int] = future.Future[Int](nio.socketWrite(channel,buf))
        def close():Unit = nio.socketClose(channel)
    new
        def accept() : future.Future[Socket]
            future.Future[Unit](nio.serverAccept(channel)).andThen[Socket](
                (channel:Unit) => makeSocketFromChannel(channel)
            )
/*
def makeSocket(hostname : String, port : Int) : future.Future[Socket]
    val channel = nio.makeSocketChannel()
    val connected : future.Future[Unit] = future.Future[Unit](nio.socketChannelConnect(channel, hostname, port))
    val socket : Socket = new
        def read(buf : ByteBuffer) : future.Future[Int]
            future.Future[Int](nio.socketRead(channel, buf))
        def write(buf : ByteBuffer) : future.Future[Int]
            future.Future[Int](nio.socketWrite(channel, buf))
        def close() : Unit
            nio.socketClose(channel)
    new
        type T = Socket
        def get() : Socket
            val wait = connected.get() //blocks until done
            socket
        def isCancelled() : Boolean = connected.isCancelled()
        def isDone() : Boolean = connected.isDone()
        def cancel() : Boolean = connected.cancel()
        def andThen[U](cb : this.T -> U) : future.Future[U]
            val conv = (() => 
                socket
            )
            val temp : future.Future[this.T] = connected.andThen[this.T](conv)
            temp.andThen[U](cb)
*/
def makeByteBuffer(allocSize : Int) : ByteBuffer
    val buffer = nio.makeByteBuffer(allocSize)
    new
        val size = allocSize
        def get(index : Int) : Int
            nio.byteBufferGet(buffer, index)
        def set(index : Int, value : Int) : Unit
            nio.byteBufferSet(buffer, index, value)
